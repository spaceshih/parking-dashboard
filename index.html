<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœè»Šå ´è³‡è¨Šå„€è¡¨æ¿</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .filters {
            background: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .filter-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }

        .filter-group label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }

        select, input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .results {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .summary-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .summary-card p {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .parking-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .parking-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }

        .parking-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .parking-card h3 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .parking-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: white;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .availability-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .availability-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #feca57 50%, #48cab2 100%);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #667eea;
        }

        .no-data {
            text-align: center;
            padding: 50px;
            color: #999;
            font-size: 1.1em;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 2% auto;
            padding: 20px;
            border-radius: 15px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .modal-header h2 {
            color: #2c3e50;
            margin: 0;
        }

        /* æ’åºè¡¨é ­æ¨£å¼ */
        .sortable-header {
            cursor: pointer;
            user-select: none;
            position: relative;
            transition: background-color 0.2s;
        }
        
        .sortable-header:hover {
            background-color: #e9ecef !important;
        }
        
        .sort-indicator {
            display: inline-block;
            margin-left: 5px;
            font-size: 12px;
            color: #666;
            width: 12px;
            text-align: center;
        }
        
        .sort-indicator.asc::after {
            content: 'â–²';
        }
        
        .sort-indicator.desc::after {
            content: 'â–¼';
        }
        
        .sort-indicator.unsorted::after {
            content: 'â‡…';
            opacity: 0.3;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #667eea;
        }

        .modal-body {
            display: grid;
            gap: 30px;
        }

        .chart-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .chart-section h3 {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            margin-top: 15px;
        }

        .building-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .info-card h4 {
            margin: 0 0 5px 0;
            font-size: 1.5em;
        }

        .info-card p {
            margin: 0;
            opacity: 0.9;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .filter-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .filter-group {
                min-width: 100%;
            }
            
            .parking-list {
                grid-template-columns: 1fr;
            }

            .modal-content {
                width: 95%;
                margin: 5% auto;
            }

            .building-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš— åœè»Šå ´è³‡è¨Šå„€è¡¨æ¿</h1>
            <p>å³æ™‚æŸ¥çœ‹å„åŸå¸‚åœè»Šå ´ä½¿ç”¨ç‹€æ³èˆ‡æ­·å²è³‡æ–™</p>
        </div>

        <div class="filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label for="cityFilter">åŸå¸‚</label>
                    <select id="cityFilter">
                        <option value="">é¸æ“‡åŸå¸‚</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="zoneFilter">å€åŸŸ</label>
                    <select id="zoneFilter">
                        <option value="">é¸æ“‡å€åŸŸ</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="startDateFilter">èµ·å§‹æ—¥æœŸ</label>
                    <input type="date" id="startDateFilter">
                </div>
                
                <div class="filter-group">
                    <label for="endDateFilter">çµæŸæ—¥æœŸ</label>
                    <input type="date" id="endDateFilter">
                </div>
                
                <div class="filter-group">
                    <label for="hourStart">é–‹å§‹æ™‚é–“</label>
                    <select id="hourStart">
                        <option value="">é¸æ“‡æ™‚é–“</option>
                    </select>
                </div>
                
                <div class="filter-group">
                    <label for="hourEnd">çµæŸæ™‚é–“</label>
                    <select id="hourEnd">
                        <option value="">é¸æ“‡æ™‚é–“</option>
                    </select>
                </div>
            </div>
            
            <div class="filter-row">
                <div class="filter-group">
                    <label for="thirdpartyFilter">è¨­å‚™å» å•†</label>
                    <select id="thirdpartyFilter">
                        <option value="">å…¨éƒ¨å ´åŸŸ</option>
                        <option value="has_thirdparty">æœ‰è¨­å‚™å» å•†</option>
                        <option value="no_thirdparty">ç„¡è¨­å‚™å» å•†</option>
                    </select>
                </div>
                
                <div class="filter-group" style="justify-content: flex-end;">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="applyFilters()">åˆ†æåœæ»¿ç‡</button>
                </div>
                
                <div class="filter-group" style="justify-content: flex-end;">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="clearFilters()" style="background: #6c757d;">æ¸…é™¤ç¯©é¸</button>
                </div>
                
                <div class="filter-group" style="justify-content: flex-end;">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="showAllBuildings()" style="background: #17a2b8;">é¡¯ç¤ºæ‰€æœ‰å ´åŸŸ</button>
                </div>
            </div>
        </div>

        <div class="results">
            <div class="summary" id="summary">
                <div class="summary-card">
                    <h3 id="totalBuildings">-</h3>
                    <p>ç¸½åœè»Šå ´æ•¸</p>
                </div>
                <div class="summary-card">
                    <h3 id="totalSpaces">-</h3>
                    <p>ç¸½è»Šä½æ•¸</p>
                </div>
                <div class="summary-card">
                    <h3 id="avgAvailable">-</h3>
                    <p>å¹³å‡å‰©é¤˜è»Šä½</p>
                </div>
                <div class="summary-card">
                    <h3 id="occupancyRate">-</h3>
                    <p>å¹³å‡ä½¿ç”¨ç‡</p>
                </div>
            </div>
            
            <div id="loadingMessage" class="loading">
                è¼‰å…¥è³‡æ–™ä¸­...
            </div>
            
            <div id="parkingList" class="parking-list" style="display: none;">
            </div>
            
            <div id="noDataMessage" class="no-data" style="display: none;">
                æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„è³‡æ–™
            </div>
        </div>

        <div class="chart-container" id="chartContainer" style="display: none;">
            <h2>å„å€åŸŸåœæ»¿ç‡åˆ†æ</h2>
            <p>é¡¯ç¤ºæ¯å€‹å€åŸŸä¸­åœæ»¿å ´åŸŸï¼ˆ100%ä½¿ç”¨ç‡ï¼‰ä½”è©²å€åŸŸç¸½å ´åŸŸçš„æ¯”ä¾‹</p>
            <canvas id="occupancyChart" width="400" height="200"></canvas>
        </div>
        
        <div class="chart-container" id="buildingListContainer" style="display: none;">
            <h2>åœæ»¿å ´åŸŸæ¸…å–®</h2>
            <p>é¡¯ç¤ºåœ¨é¸å®šæ¢ä»¶ä¸‹åœæ»¿(å‰©é¤˜è»Šä½=0)çš„åœè»Šå ´</p>
            <div id="buildingTable"></div>
        </div>
    </div>

    <!-- è©³ç´°è³‡è¨Šæ¨¡æ…‹æ¡† -->
    <div id="buildingModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">åœè»Šå ´è©³ç´°è³‡è¨Š</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <div class="building-info" id="buildingInfo">
                    <!-- åŸºæœ¬è³‡è¨Šå¡ç‰‡å°‡åœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
                </div>
                
                <div class="chart-section">
                    <h3>ğŸ“Š æ¯å°æ™‚åœæ”¾ç‡åˆ†æ</h3>
                    <p>é¡¯ç¤º24å°æ™‚å…§å„æ™‚æ®µçš„å¹³å‡åœæ”¾ç‡</p>
                    <div class="chart-wrapper">
                        <canvas id="hourlyChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-section">
                    <h3>ğŸ“ˆ æ¯é€±åœæ”¾ç‡åˆ†æï¼ˆæ˜ŸæœŸä¸€åˆ°äº”ï¼‰</h3>
                    <p>é¡¯ç¤ºå·¥ä½œæ—¥å„å¤©çš„å¹³å‡åœæ”¾ç‡</p>
                    <div class="chart-wrapper">
                        <canvas id="weeklyChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // IPç™½åå–®é…ç½®
        const IP_WHITELIST = {
            // è¨­å®šå…è¨±çš„IPåœ°å€å’Œç¯„åœ
            allowedIPs: [
                '123.192.164.188',      // æˆæ¬ŠIP 1
                '123.193.254.217',      // æˆæ¬ŠIP 2
                '127.0.0.1',            // æœ¬åœ°æ¸¬è©¦
                'localhost'             // æœ¬åœ°æ¸¬è©¦
            ],
            // é–‹ç™¼æ¨¡å¼ - è¨­ç‚ºfalseå•Ÿç”¨IPç™½åå–®
            developmentMode: false
        };

        // IPæª¢æŸ¥å‡½æ•¸
        function isIPInRange(ip, cidr) {
            if (cidr.indexOf('/') === -1) {
                return ip === cidr;
            }
            
            const [range, bits] = cidr.split('/');
            const mask = ~(2 ** (32 - bits) - 1);
            
            const ipNum = ip.split('.').reduce((num, oct) => (num << 8) + parseInt(oct, 10), 0) >>> 0;
            const rangeNum = range.split('.').reduce((num, oct) => (num << 8) + parseInt(oct, 10), 0) >>> 0;
            
            return (ipNum & mask) === (rangeNum & mask);
        }
        
        // æª¢æŸ¥è¨ªå•æ¬Šé™
        async function checkAccess() {
            // é–‹ç™¼æ¨¡å¼è·³éæª¢æŸ¥
            if (IP_WHITELIST.developmentMode) {
                console.log('é–‹ç™¼æ¨¡å¼ï¼šè·³éIPæª¢æŸ¥');
                return true;
            }
            
            try {
                // ç²å–ç”¨æˆ¶IP
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                const userIP = data.ip;
                
                console.log('ç”¨æˆ¶IP:', userIP);
                
                // æª¢æŸ¥IPæ˜¯å¦åœ¨ç™½åå–®ä¸­
                for (const allowedIP of IP_WHITELIST.allowedIPs) {
                    if (isIPInRange(userIP, allowedIP)) {
                        console.log(`IP ${userIP} å·²æˆæ¬Šè¨ªå•`);
                        return true;
                    }
                }
                
                console.log(`IP ${userIP} æœªæˆæ¬Šè¨ªå•`);
                return false;
                
            } catch (error) {
                console.error('IPæª¢æŸ¥å¤±æ•—:', error);
                // ç¶²è·¯éŒ¯èª¤æ™‚å…è¨±è¨ªå•ï¼ˆå¯é¸ï¼‰
                return true;
            }
        }
        
        // é¡¯ç¤ºæ‹’çµ•è¨ªå•é é¢
        function showAccessDenied() {
            document.body.innerHTML = `
                <div style="
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    height: 100vh;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    font-family: Arial, sans-serif;
                    color: white;
                    text-align: center;
                ">
                    <div style="
                        background: white;
                        color: #333;
                        padding: 40px;
                        border-radius: 15px;
                        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                        max-width: 500px;
                    ">
                        <h1 style="margin: 0 0 20px 0; color: #dc3545;">ğŸš« è¨ªå•å—é™</h1>
                        <p style="margin: 0 0 15px 0; font-size: 1.1em;">
                            å¾ˆæŠ±æ­‰ï¼Œæ­¤ç³»çµ±åƒ…é™æˆæ¬ŠIPåœ°å€è¨ªå•ã€‚
                        </p>
                        <p style="margin: 0; color: #666; font-size: 0.9em;">
                            å¦‚éœ€è¨ªå•æ¬Šé™ï¼Œè«‹è¯ç¹«ç³»çµ±ç®¡ç†å“¡ã€‚
                        </p>
                        <div style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                            <small style="color: #666;">éŒ¯èª¤ä»£ç¢¼: ACCESS_DENIED_IP</small>
                        </div>
                    </div>
                </div>
            `;
        }

    </script>
    <script>
        let buildingsData = [];
        let parkingData = [];
        let filteredData = [];
        let validBuildings = []; // Buildings with space_number > 0
        let chart = null;
        let hourlyChart = null;
        
        // æ’åºç‹€æ…‹
        let currentSortColumn = '';
        let currentSortOrder = 'desc'; // 'asc' æˆ– 'desc'
        let currentBuildings = []; // å„²å­˜ç•¶å‰é¡¯ç¤ºçš„å»ºç‰©åˆ—è¡¨
        let weeklyChart = null;
        let modal = null;

        // Initialize the dashboard
        async function init() {
            try {
                // æª¢æŸ¥IPè¨ªå•æ¬Šé™
                const hasAccess = await checkAccess();
                if (!hasAccess) {
                    showAccessDenied();
                    return;
                }
                
                await loadData();
                filterValidBuildings();
                initializeFilters();
                showAllBuildings();
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                document.getElementById('loadingMessage').textContent = 'è¼‰å…¥è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤';
            }
        }

        // Filter buildings with space_number > 0 and have shared parking data
        function filterValidBuildings() {
            // First filter by space_number > 0
            let filteredBuildings = buildingsData.filter(b => {
                const spaceNumber = parseInt(b.space_number || 0);
                return spaceNumber > 0;
            });
            
            // Then filter out buildings that have only zero remaining spaces (no sharing)
            const buildingsWithNonZeroData = new Set();
            
            // Group parking data by building and check for non-zero values
            parkingData.forEach(p => {
                const remaining = parseFloat(p.avg_available_space || 0);
                if (remaining > 0) {
                    buildingsWithNonZeroData.add(p.building_id);
                }
            });
            
            // Only include buildings that have at least one non-zero remaining space record
            validBuildings = filteredBuildings.filter(b => buildingsWithNonZeroData.has(b.id));
            
            console.log('Buildings with space > 0:', filteredBuildings.length);
            console.log('Buildings with sharing data (non-zero remaining):', validBuildings.length);
            console.log('Filtered out (no sharing):', filteredBuildings.length - validBuildings.length);
        }

        // Load CSV data
        async function loadData() {
            try {
                console.log('Starting to load data...');
                
                // Load buildings data
                console.log('Fetching buildings data...');
                const buildingsResponse = await fetch('å»ºç‰©.csv');
                if (!buildingsResponse.ok) {
                    throw new Error(`Failed to fetch buildings data: ${buildingsResponse.status}`);
                }
                const buildingsText = await buildingsResponse.text();
                console.log('Buildings CSV text length:', buildingsText.length);
                buildingsData = parseCSV(buildingsText);
                
                // Load parking data
                console.log('Fetching parking data...');
                const parkingResponse = await fetch('å‰©é¤˜è»Šä½æ•¸.csv');
                if (!parkingResponse.ok) {
                    throw new Error(`Failed to fetch parking data: ${parkingResponse.status}`);
                }
                const parkingText = await parkingResponse.text();
                console.log('Parking CSV text length:', parkingText.length);
                parkingData = parseCSV(parkingText);
                
                console.log('Buildings loaded:', buildingsData.length);
                console.log('Parking data loaded:', parkingData.length);
                
                if (buildingsData.length === 0) {
                    throw new Error('No buildings data loaded');
                }
                if (parkingData.length === 0) {
                    throw new Error('No parking data loaded');
                }
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loadingMessage').textContent = `è¼‰å…¥è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤: ${error.message}`;
                throw error;
            }
        }

        // Parse CSV data with improved quoted field handling
        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = parseCSVLine(lines[0]).map(h => h.replace(/^"|"$/g, ''));
            const data = [];
            
            console.log('CSV Headers:', headers);
            
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;
                
                const values = parseCSVLine(lines[i]);
                if (values.length >= headers.length) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] ? values[index].replace(/^"|"$/g, '') : '';
                    });
                    data.push(row);
                }
            }
            
            console.log('Parsed data sample:', data.slice(0, 3));
            return data;
        }

        // Improved CSV line parsing
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            let i = 0;
            
            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Handle escaped quotes
                        current += '"';
                        i += 2;
                        continue;
                    }
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                    i++;
                    continue;
                } else {
                    current += char;
                }
                i++;
            }
            
            values.push(current);
            return values;
        }

        // Initialize filter options
        function initializeFilters() {
            // Populate city filter with valid buildings only
            const cities = [...new Set(validBuildings.map(b => b.city))].sort();
            const cityFilter = document.getElementById('cityFilter');
            cityFilter.innerHTML = '<option value="">é¸æ“‡åŸå¸‚</option>';
            cities.forEach(city => {
                const option = document.createElement('option');
                option.value = city;
                option.textContent = city;
                cityFilter.appendChild(option);
            });

            // Populate hour filters
            const hourStart = document.getElementById('hourStart');
            const hourEnd = document.getElementById('hourEnd');
            for (let i = 0; i < 24; i++) {
                const hourText = i.toString().padStart(2, '0') + ':00';
                
                const optionStart = document.createElement('option');
                optionStart.value = i;
                optionStart.textContent = hourText;
                hourStart.appendChild(optionStart);
                
                const optionEnd = document.createElement('option');
                optionEnd.value = i;
                optionEnd.textContent = hourText;
                hourEnd.appendChild(optionEnd);
            }

            // City change handler
            cityFilter.addEventListener('change', function() {
                updateZoneFilter(this.value);
            });

            // Date validation handlers
            const startDateFilter = document.getElementById('startDateFilter');
            const endDateFilter = document.getElementById('endDateFilter');
            
            startDateFilter.addEventListener('change', function() {
                if (endDateFilter.value && this.value > endDateFilter.value) {
                    alert('èµ·å§‹æ—¥æœŸä¸èƒ½æ™šæ–¼çµæŸæ—¥æœŸ');
                    this.value = '';
                }
            });
            
            endDateFilter.addEventListener('change', function() {
                if (startDateFilter.value && this.value < startDateFilter.value) {
                    alert('çµæŸæ—¥æœŸä¸èƒ½æ—©æ–¼èµ·å§‹æ—¥æœŸ');
                    this.value = '';
                }
            });
        }

        // Update zone filter based on selected city
        function updateZoneFilter(selectedCity) {
            const zoneFilter = document.getElementById('zoneFilter');
            zoneFilter.innerHTML = '<option value="">é¸æ“‡å€åŸŸ</option>';
            
            if (selectedCity) {
                const zones = [...new Set(validBuildings
                    .filter(b => b.city === selectedCity)
                    .map(b => b.zone))].sort();
                
                zones.forEach(zone => {
                    const option = document.createElement('option');
                    option.value = zone;
                    option.textContent = zone;
                    zoneFilter.appendChild(option);
                });
            }
        }

        // Apply filters and analyze occupancy rates by district
        function applyFilters() {
            const city = document.getElementById('cityFilter').value;
            const zone = document.getElementById('zoneFilter').value;
            const startDate = document.getElementById('startDateFilter').value;
            const endDate = document.getElementById('endDateFilter').value;
            const hourStart = document.getElementById('hourStart').value;
            const hourEnd = document.getElementById('hourEnd').value;
            const thirdpartyFilter = document.getElementById('thirdpartyFilter').value;

            // Filter valid buildings
            let filteredBuildings = validBuildings;
            
            if (city) {
                filteredBuildings = filteredBuildings.filter(b => b.city === city);
            }
            if (zone) {
                filteredBuildings = filteredBuildings.filter(b => b.zone === zone);
            }
            
            // Apply thirdparty filter
            if (thirdpartyFilter === 'has_thirdparty') {
                filteredBuildings = filteredBuildings.filter(b => b.thirdparty_name && b.thirdparty_name.trim() !== '' && b.thirdparty_name !== 'NULL');
            } else if (thirdpartyFilter === 'no_thirdparty') {
                filteredBuildings = filteredBuildings.filter(b => !b.thirdparty_name || b.thirdparty_name.trim() === '' || b.thirdparty_name === 'NULL');
            }

            // Get building IDs
            const buildingIds = new Set(filteredBuildings.map(b => b.id));

            // Filter parking data
            let filteredParkingData = parkingData.filter(p => buildingIds.has(p.building_id));

            // Apply date range filter
            if (startDate || endDate) {
                filteredParkingData = filteredParkingData.filter(p => {
                    const parkingDate = p.date;
                    let withinRange = true;
                    
                    if (startDate && parkingDate < startDate) {
                        withinRange = false;
                    }
                    if (endDate && parkingDate > endDate) {
                        withinRange = false;
                    }
                    
                    return withinRange;
                });
            }

            // Apply hour range filter
            if (hourStart !== '' && hourEnd !== '') {
                const start = parseInt(hourStart);
                const end = parseInt(hourEnd);
                filteredParkingData = filteredParkingData.filter(p => {
                    const hour = parseInt(p.hour);
                    return start <= end ? (hour >= start && hour <= end) : (hour >= start || hour <= end);
                });
            } else if (hourStart !== '') {
                const start = parseInt(hourStart);
                filteredParkingData = filteredParkingData.filter(p => parseInt(p.hour) >= start);
            } else if (hourEnd !== '') {
                const end = parseInt(hourEnd);
                filteredParkingData = filteredParkingData.filter(p => parseInt(p.hour) <= end);
            }

            // Calculate occupancy rate by district and show full parking lots
            calculateDistrictOccupancy(filteredBuildings, filteredParkingData);
            showFullParkingLots(filteredBuildings, filteredParkingData);
        }

        // Calculate and display district occupancy rates
        function calculateDistrictOccupancy(buildings, parkingData) {
            // Group buildings by district (city + zone)
            const districtData = {};
            
            buildings.forEach(building => {
                const district = `${building.city} ${building.zone}`;
                if (!districtData[district]) {
                    districtData[district] = {
                        totalBuildings: 0,
                        fullBuildings: 0,
                        buildings: []
                    };
                }
                districtData[district].totalBuildings++;
                districtData[district].buildings.push(building);
            });

            // Check which buildings are 100% occupied (å‰©é¤˜è»Šä½ = 0)
            parkingData.forEach(p => {
                const building = buildings.find(b => b.id === p.building_id);
                if (building) {
                    const district = `${building.city} ${building.zone}`;
                    const totalSpaces = parseInt(building.space_number || 0);
                    const availableSpaces = parseFloat(p.avg_available_space || 0);
                    
                    // Check if parking lot is 100% full (no available spaces)
                    if (availableSpaces === 0 && totalSpaces > 0) {
                        // Mark this building as full for this time period
                        if (!districtData[district].fullBuildingsSet) {
                            districtData[district].fullBuildingsSet = new Set();
                        }
                        districtData[district].fullBuildingsSet.add(p.building_id);
                    }
                }
            });

            // Calculate percentages
            Object.keys(districtData).forEach(district => {
                const data = districtData[district];
                data.fullBuildings = data.fullBuildingsSet ? data.fullBuildingsSet.size : 0;
                data.occupancyRate = data.totalBuildings > 0 ? (data.fullBuildings / data.totalBuildings * 100) : 0;
            });

            updateOccupancyChart(districtData);
            updateSummaryForOccupancy(districtData);
        }

        // Filter data by date range
        function filterByDateRange(data, range) {
            const today = new Date();
            let startDate, endDate;

            switch (range) {
                case 'last_weekend':
                    // Get last Saturday and Sunday
                    const lastSaturday = new Date(today);
                    lastSaturday.setDate(today.getDate() - today.getDay() - 1);
                    const lastSunday = new Date(lastSaturday);
                    lastSunday.setDate(lastSaturday.getDate() + 1);
                    
                    return data.filter(p => {
                        const date = new Date(p.date);
                        return (date.toDateString() === lastSaturday.toDateString() || 
                                date.toDateString() === lastSunday.toDateString());
                    });

                case 'this_week':
                    const startOfWeek = new Date(today);
                    startOfWeek.setDate(today.getDate() - today.getDay() + 1);
                    endDate = new Date(today);
                    
                    return data.filter(p => {
                        const date = new Date(p.date);
                        return date >= startOfWeek && date <= endDate;
                    });

                case 'last_week':
                    const startOfLastWeek = new Date(today);
                    startOfLastWeek.setDate(today.getDate() - today.getDay() - 6);
                    const endOfLastWeek = new Date(today);
                    endOfLastWeek.setDate(today.getDate() - today.getDay());
                    
                    return data.filter(p => {
                        const date = new Date(p.date);
                        return date >= startOfLastWeek && date <= endOfLastWeek;
                    });

                default:
                    return data;
            }
        }

        // Update display with filtered data
        function updateDisplay(buildings, parkingData) {
            document.getElementById('loadingMessage').style.display = 'none';
            
            if (buildings.length === 0 || parkingData.length === 0) {
                document.getElementById('noDataMessage').style.display = 'block';
                document.getElementById('parkingList').style.display = 'none';
                document.getElementById('chartContainer').style.display = 'none';
                updateSummary([], []);
                return;
            }

            document.getElementById('noDataMessage').style.display = 'none';
            document.getElementById('parkingList').style.display = 'grid';
            
            updateSummary(buildings, parkingData);
            updateParkingList(buildings, parkingData);
            updateChart(parkingData);
        }

        // Update summary statistics
        function updateSummary(buildings, parkingData) {
            const totalBuildings = buildings.length;
            const totalSpaces = buildings.reduce((sum, b) => sum + parseInt(b.space_number || 0), 0);
            
            let avgAvailable = 0;
            let occupancyRate = 0;
            
            if (parkingData.length > 0) {
                avgAvailable = parkingData.reduce((sum, p) => sum + parseFloat(p.avg_available_space || 0), 0) / parkingData.length;
                
                if (totalSpaces > 0) {
                    occupancyRate = ((totalSpaces - avgAvailable) / totalSpaces * 100);
                }
            }

            document.getElementById('totalBuildings').textContent = totalBuildings;
            document.getElementById('totalSpaces').textContent = totalSpaces.toLocaleString();
            document.getElementById('avgAvailable').textContent = Math.round(avgAvailable);
            document.getElementById('occupancyRate').textContent = Math.round(occupancyRate) + '%';
        }

        // Update parking list
        function updateParkingList(buildings, parkingData) {
            const parkingList = document.getElementById('parkingList');
            parkingList.innerHTML = '';

            // Group parking data by building
            const parkingByBuilding = {};
            parkingData.forEach(p => {
                if (!parkingByBuilding[p.building_id]) {
                    parkingByBuilding[p.building_id] = [];
                }
                parkingByBuilding[p.building_id].push(p);
            });

            buildings.forEach(building => {
                const buildingParkingData = parkingByBuilding[building.id] || [];
                const avgAvailable = buildingParkingData.length > 0 ? 
                    buildingParkingData.reduce((sum, p) => sum + parseFloat(p.avg_available_space || 0), 0) / buildingParkingData.length : 0;
                
                const totalSpaces = parseInt(building.space_number || 0);
                const occupancyRate = totalSpaces > 0 ? ((totalSpaces - avgAvailable) / totalSpaces * 100) : 0;

                const card = document.createElement('div');
                card.className = 'parking-card';
                card.onclick = () => showBuildingDetail(building, buildingParkingData);
                
                card.innerHTML = `
                    <h3>${building.name}</h3>
                    <div class="parking-info">
                        <div class="info-item">
                            <span>åŸå¸‚</span>
                            <span>${building.city}</span>
                        </div>
                        <div class="info-item">
                            <span>å€åŸŸ</span>
                            <span>${building.zone}</span>
                        </div>
                        <div class="info-item">
                            <span>ç¸½è»Šä½</span>
                            <span>${totalSpaces}</span>
                        </div>
                        <div class="info-item">
                            <span>å¹³å‡å‰©é¤˜</span>
                            <span>${Math.round(avgAvailable)}</span>
                        </div>
                    </div>
                    <div class="availability-bar">
                        <div class="availability-fill" style="width: ${occupancyRate}%"></div>
                    </div>
                    <p style="text-align: center; margin-top: 10px; font-size: 0.9em; color: #666;">
                        ä½¿ç”¨ç‡: ${Math.round(occupancyRate)}%
                    </p>
                `;
                
                parkingList.appendChild(card);
            });
        }

        // Show building detail in modal
        function showBuildingDetail(building, parkingData) {
            // è¨­å®šæ¨¡æ…‹æ¡†æ¨™é¡Œ
            document.getElementById('modalTitle').textContent = building.name + ' - è©³ç´°åˆ†æ';
            
            // ç”ŸæˆåŸºæœ¬è³‡è¨Šå¡ç‰‡
            generateBuildingInfo(building, parkingData);
            
            // ç”Ÿæˆæ¯å°æ™‚åœæ”¾ç‡åœ–è¡¨
            generateHourlyChart(building, parkingData);
            
            // ç”Ÿæˆæ¯é€±åœæ”¾ç‡åœ–è¡¨
            generateWeeklyChart(building, parkingData);
            
            // é¡¯ç¤ºæ¨¡æ…‹æ¡†
            modal.style.display = 'block';
        }

        // ç”Ÿæˆå»ºç‰©åŸºæœ¬è³‡è¨Šå¡ç‰‡
        function generateBuildingInfo(building, parkingData) {
            const totalSpaces = parseInt(building.space_number || 0);
            const avgAvailable = parkingData.length > 0 ? 
                parkingData.reduce((sum, p) => sum + parseFloat(p.avg_available_space || 0), 0) / parkingData.length : 0;
            const avgOccupancyRate = totalSpaces > 0 ? ((totalSpaces - avgAvailable) / totalSpaces * 100) : 0;
            const address = building['concat(b.city,b.zone,b.road)'] || `${building.city}${building.zone}`;
            
            const infoHTML = `
                <div class="info-card">
                    <h4>${building.name}</h4>
                    <p>åœè»Šå ´åç¨±</p>
                </div>
                <div class="info-card">
                    <h4>${building.city} ${building.zone}</h4>
                    <p>æ‰€åœ¨å€åŸŸ</p>
                </div>
                <div class="info-card">
                    <h4>${totalSpaces}</h4>
                    <p>ç¸½è»Šä½æ•¸</p>
                </div>
                <div class="info-card">
                    <h4>${Math.round(avgAvailable)}</h4>
                    <p>å¹³å‡å‰©é¤˜è»Šä½</p>
                </div>
                <div class="info-card">
                    <h4>${Math.round(avgOccupancyRate)}%</h4>
                    <p>å¹³å‡åœæ”¾ç‡</p>
                </div>
                <div class="info-card">
                    <h4>${building.in_operation === '1' ? 'ç‡Ÿé‹ä¸­' : 'åœæ­¢ç‡Ÿé‹'}</h4>
                    <p>ç‡Ÿé‹ç‹€æ…‹</p>
                </div>
            `;
            
            document.getElementById('buildingInfo').innerHTML = infoHTML;
        }

        // ç”Ÿæˆæ¯å°æ™‚åœæ”¾ç‡åœ–è¡¨
        function generateHourlyChart(building, parkingData) {
            const totalSpaces = parseInt(building.space_number || 0);
            if (totalSpaces === 0) return;
            
            // æŒ‰å°æ™‚åˆ†çµ„è¨ˆç®—å¹³å‡åœæ”¾ç‡
            const hourlyData = {};
            for (let hour = 0; hour < 24; hour++) {
                hourlyData[hour] = [];
            }
            
            parkingData.forEach(p => {
                const hour = parseInt(p.hour);
                const availableSpaces = parseFloat(p.avg_available_space || 0);
                const occupancyRate = ((totalSpaces - availableSpaces) / totalSpaces * 100);
                if (hourlyData[hour]) {
                    hourlyData[hour].push(occupancyRate);
                }
            });
            
            // è¨ˆç®—æ¯å°æ™‚å¹³å‡åœæ”¾ç‡
            const hourlyRates = [];
            const hourLabels = [];
            for (let hour = 0; hour < 24; hour++) {
                const rates = hourlyData[hour];
                const avgRate = rates.length > 0 ? rates.reduce((sum, rate) => sum + rate, 0) / rates.length : 0;
                hourlyRates.push(avgRate);
                hourLabels.push(hour.toString().padStart(2, '0') + ':00');
            }
            
            const ctx = document.getElementById('hourlyChart').getContext('2d');
            
            if (hourlyChart) {
                hourlyChart.destroy();
            }
            
            hourlyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: hourLabels,
                    datasets: [{
                        label: 'åœæ”¾ç‡ (%)',
                        data: hourlyRates,
                        borderColor: 'rgba(102, 126, 234, 1)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: '24å°æ™‚åœæ”¾ç‡è®ŠåŒ–'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'åœæ”¾ç‡ (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'æ™‚é–“'
                            }
                        }
                    }
                }
            });
        }

        // ç”Ÿæˆæ¯é€±åœæ”¾ç‡åœ–è¡¨ï¼ˆæ˜ŸæœŸä¸€åˆ°äº”ï¼‰
        function generateWeeklyChart(building, parkingData) {
            const totalSpaces = parseInt(building.space_number || 0);
            if (totalSpaces === 0) return;
            
            // æŒ‰æ˜ŸæœŸåˆ†çµ„è¨ˆç®—å¹³å‡åœæ”¾ç‡ï¼ˆ1=æ˜ŸæœŸä¸€, 2=æ˜ŸæœŸäºŒ, ..., 5=æ˜ŸæœŸäº”ï¼‰
            const weeklyData = { 1: [], 2: [], 3: [], 4: [], 5: [] };
            
            parkingData.forEach(p => {
                const date = new Date(p.date);
                const dayOfWeek = date.getDay(); // 0=æ˜ŸæœŸæ—¥, 1=æ˜ŸæœŸä¸€, ..., 6=æ˜ŸæœŸå…­
                
                // åªè¨ˆç®—æ˜ŸæœŸä¸€åˆ°äº”
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    const availableSpaces = parseFloat(p.avg_available_space || 0);
                    const occupancyRate = ((totalSpaces - availableSpaces) / totalSpaces * 100);
                    weeklyData[dayOfWeek].push(occupancyRate);
                }
            });
            
            // è¨ˆç®—æ¯å¤©å¹³å‡åœæ”¾ç‡
            const weeklyRates = [];
            const weekLabels = ['æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”'];
            
            for (let day = 1; day <= 5; day++) {
                const rates = weeklyData[day];
                const avgRate = rates.length > 0 ? rates.reduce((sum, rate) => sum + rate, 0) / rates.length : 0;
                weeklyRates.push(avgRate);
            }
            
            const ctx = document.getElementById('weeklyChart').getContext('2d');
            
            if (weeklyChart) {
                weeklyChart.destroy();
            }
            
            weeklyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weekLabels,
                    datasets: [{
                        label: 'åœæ”¾ç‡ (%)',
                        data: weeklyRates,
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.8)',
                            'rgba(54, 162, 235, 0.8)',
                            'rgba(255, 205, 86, 0.8)',
                            'rgba(75, 192, 192, 0.8)',
                            'rgba(153, 102, 255, 0.8)'
                        ],
                        borderColor: [
                            'rgba(255, 99, 132, 1)',
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 205, 86, 1)',
                            'rgba(75, 192, 192, 1)',
                            'rgba(153, 102, 255, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'å·¥ä½œæ—¥åœæ”¾ç‡æ¯”è¼ƒ'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'åœæ”¾ç‡ (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'æ˜ŸæœŸ'
                            }
                        }
                    }
                }
            });
        }

        // Update occupancy chart
        function updateOccupancyChart(districtData) {
            document.getElementById('chartContainer').style.display = 'block';
            document.getElementById('parkingList').style.display = 'none';

            const districts = Object.keys(districtData).sort();
            const occupancyRates = districts.map(d => districtData[d].occupancyRate);
            const fullCounts = districts.map(d => `${districtData[d].fullBuildings}/${districtData[d].totalBuildings}`);

            const ctx = document.getElementById('occupancyChart').getContext('2d');
            
            if (chart) {
                chart.destroy();
            }

            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: districts,
                    datasets: [{
                        label: 'åœæ»¿ç‡ (%)',
                        data: occupancyRates,
                        backgroundColor: occupancyRates.map(rate => {
                            if (rate >= 80) return 'rgba(255, 99, 132, 0.8)'; // Red for high occupancy
                            if (rate >= 50) return 'rgba(255, 205, 86, 0.8)'; // Yellow for medium
                            return 'rgba(75, 192, 192, 0.8)'; // Green for low
                        }),
                        borderColor: occupancyRates.map(rate => {
                            if (rate >= 80) return 'rgba(255, 99, 132, 1)';
                            if (rate >= 50) return 'rgba(255, 205, 86, 1)';
                            return 'rgba(75, 192, 192, 1)';
                        }),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'å„å€åŸŸåœæ»¿ç‡åˆ†æ'
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const index = context.dataIndex;
                                    return `åœæ»¿å ´åŸŸ: ${fullCounts[index]}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'åœæ»¿ç‡ (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'å€åŸŸ'
                            }
                        }
                    }
                }
            });
        }

        // Update summary for occupancy analysis
        function updateSummaryForOccupancy(districtData) {
            document.getElementById('loadingMessage').style.display = 'none';
            
            const districts = Object.keys(districtData);
            const totalBuildings = districts.reduce((sum, d) => sum + districtData[d].totalBuildings, 0);
            const totalFullBuildings = districts.reduce((sum, d) => sum + districtData[d].fullBuildings, 0);
            const avgOccupancyRate = districts.length > 0 ? 
                districts.reduce((sum, d) => sum + districtData[d].occupancyRate, 0) / districts.length : 0;

            document.getElementById('totalBuildings').textContent = totalBuildings;
            document.getElementById('totalSpaces').textContent = districts.length + ' å€åŸŸ';
            document.getElementById('avgAvailable').textContent = totalFullBuildings + ' åœæ»¿å ´åŸŸ';
            document.getElementById('occupancyRate').textContent = Math.round(avgOccupancyRate) + '%';
        }

        // Clear all filters
        function clearFilters() {
            document.getElementById('cityFilter').value = '';
            document.getElementById('zoneFilter').value = '';
            document.getElementById('startDateFilter').value = '';
            document.getElementById('endDateFilter').value = '';
            document.getElementById('hourStart').value = '';
            document.getElementById('hourEnd').value = '';
            document.getElementById('thirdpartyFilter').value = '';
            
            // Update zone filter
            updateZoneFilter('');
            
            // Hide charts and show default state
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('buildingListContainer').style.display = 'none';
            document.getElementById('parkingList').style.display = 'none';
            document.getElementById('loadingMessage').style.display = 'block';
            document.getElementById('loadingMessage').textContent = 'è«‹é¸æ“‡æ¢ä»¶é€²è¡Œåˆ†ææˆ–é»æ“Š"é¡¯ç¤ºæ‰€æœ‰å ´åŸŸ"';
        }

        // Show all buildings with space_number > 0
        function showAllBuildings() {
            document.getElementById('chartContainer').style.display = 'none';
            document.getElementById('parkingList').style.display = 'none';
            document.getElementById('buildingListContainer').style.display = 'block';
            document.getElementById('loadingMessage').style.display = 'none';
            
            // Apply filters to buildings
            const city = document.getElementById('cityFilter').value;
            const zone = document.getElementById('zoneFilter').value;
            const thirdpartyFilter = document.getElementById('thirdpartyFilter').value;
            
            let filteredBuildings = validBuildings;
            
            if (city) {
                filteredBuildings = filteredBuildings.filter(b => b.city === city);
            }
            if (zone) {
                filteredBuildings = filteredBuildings.filter(b => b.zone === zone);
            }
            
            // Apply thirdparty filter
            if (thirdpartyFilter === 'has_thirdparty') {
                filteredBuildings = filteredBuildings.filter(b => b.thirdparty_name && b.thirdparty_name.trim() !== '' && b.thirdparty_name !== 'NULL');
            } else if (thirdpartyFilter === 'no_thirdparty') {
                filteredBuildings = filteredBuildings.filter(b => !b.thirdparty_name || b.thirdparty_name.trim() === '' || b.thirdparty_name === 'NULL');
            }
            
            // For showing all buildings, we need to add zeroRemainingPercentage = 0 since no parking data is filtered
            const buildingsWithZeroPercentage = filteredBuildings.map(building => ({
                ...building,
                avgRemaining: 0,
                avgParked: 0,
                zeroRemainingPercentage: 0
            }));
            
            displayFullBuildingsList(buildingsWithZeroPercentage);
            updateSummaryForBuildings(filteredBuildings);
        }

        // Show full parking lots list
        function showFullParkingLots(buildings, parkingData) {
            document.getElementById('buildingListContainer').style.display = 'block';
            
            // Find buildings that are 100% full
            const fullBuildings = [];
            const buildingParkingMap = {};
            
            // Group parking data by building
            parkingData.forEach(p => {
                if (!buildingParkingMap[p.building_id]) {
                    buildingParkingMap[p.building_id] = [];
                }
                buildingParkingMap[p.building_id].push(p);
            });
            
            // Check which buildings are full
            buildings.forEach(building => {
                const buildingParking = buildingParkingMap[building.id] || [];
                const totalSpaces = parseInt(building.space_number || 0);
                
                // Check if any time period shows 0 available spaces
                const hasFull = buildingParking.some(p => {
                    const availableSpaces = parseFloat(p.avg_available_space || 0);
                    return availableSpaces === 0 && totalSpaces > 0;
                });
                
                if (hasFull) {
                    // Calculate average remaining spaces for this building
                    const avgRemaining = buildingParking.length > 0 ? 
                        buildingParking.reduce((sum, p) => sum + parseFloat(p.avg_available_space || 0), 0) / buildingParking.length : 0;
                    
                    // Calculate percentage of time slots with 0 remaining spaces
                    const totalTimeSlots = buildingParking.length;
                    const zeroRemainingSlots = buildingParking.filter(p => {
                        const availableSpaces = parseFloat(p.avg_available_space || 0);
                        return availableSpaces === 0;
                    }).length;
                    const zeroRemainingPercentage = totalTimeSlots > 0 ? (zeroRemainingSlots / totalTimeSlots * 100) : 0;
                    
                    // Calculate average parked vehicles (ç¸½è»Šä½ - å¹³å‡å‰©é¤˜è»Šä½)
                    const avgParked = Math.max(0, totalSpaces - avgRemaining);
                    
                    fullBuildings.push({
                        ...building,
                        avgRemaining: avgRemaining,
                        avgParked: avgParked,
                        zeroRemainingPercentage: zeroRemainingPercentage
                    });
                }
            });
            
            displayFullBuildingsList(fullBuildings);
        }

        // Display full buildings in a list format
        function displayFullBuildingsList(buildings) {
            const tableContainer = document.getElementById('buildingTable');
            
            if (buildings.length === 0) {
                tableContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #666;">åœ¨é¸å®šæ¢ä»¶ä¸‹æ²’æœ‰åœæ»¿çš„åœè»Šå ´</p>';
                return;
            }
            
            // å„²å­˜ç•¶å‰å»ºç‰©åˆ—è¡¨ä¾›æ’åºä½¿ç”¨
            currentBuildings = [...buildings];
            
            let listHTML = `
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                        <thead>
                            <tr style="background-color: #f8f9fa;">
                                <th class="sortable-header" data-sort="name" style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">
                                    å»ºç‰©åç¨±<span class="sort-indicator ${getSortIndicatorClass('name')}"></span>
                                </th>
                                <th class="sortable-header" data-sort="city" style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">
                                    å€åŸŸ<span class="sort-indicator ${getSortIndicatorClass('city')}"></span>
                                </th>
                                <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">åœ°å€</th>
                                <th class="sortable-header" data-sort="space_number" style="border: 1px solid #dee2e6; padding: 12px; text-align: right;">
                                    ç¸½è»Šæ ¼æ•¸<span class="sort-indicator ${getSortIndicatorClass('space_number')}"></span>
                                </th>
                                <th class="sortable-header" data-sort="avgRemaining" style="border: 1px solid #dee2e6; padding: 12px; text-align: right;">
                                    å¹³å‡å‰©é¤˜è»Šæ ¼æ•¸<span class="sort-indicator ${getSortIndicatorClass('avgRemaining')}"></span>
                                </th>
                                <th class="sortable-header" data-sort="avgParked" style="border: 1px solid #dee2e6; padding: 12px; text-align: right;">
                                    å¹³å‡åœæ”¾è»Šè¼›æ•¸<span class="sort-indicator ${getSortIndicatorClass('avgParked')}"></span>
                                </th>
                                <th class="sortable-header" data-sort="zeroRemainingPercentage" style="border: 1px solid #dee2e6; padding: 12px; text-align: right;">
                                    å‰©é¤˜è»Šæ ¼=0çš„ä½”æ¯”<span class="sort-indicator ${getSortIndicatorClass('zeroRemainingPercentage')}"></span>
                                </th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            buildings.forEach(building => {
                const address = building['concat(b.city,b.zone,b.road)'] || `${building.city}${building.zone}`;
                const region = `${building.city} ${building.zone}`;
                
                const zeroPercentage = building.zeroRemainingPercentage || 0;
                listHTML += `
                    <tr style="border-bottom: 1px solid #dee2e6;">
                        <td style="border: 1px solid #dee2e6; padding: 12px;">${building.name}</td>
                        <td style="border: 1px solid #dee2e6; padding: 12px;">${region}</td>
                        <td style="border: 1px solid #dee2e6; padding: 12px; font-size: 0.9em;">${address}</td>
                        <td style="border: 1px solid #dee2e6; padding: 12px; text-align: right;">${building.space_number}</td>
                        <td style="border: 1px solid #dee2e6; padding: 12px; text-align: right;">${Math.round(building.avgRemaining)}</td>
                        <td style="border: 1px solid #dee2e6; padding: 12px; text-align: right; color: #0066cc;">${Math.round(building.avgParked || 0)}</td>
                        <td style="border: 1px solid #dee2e6; padding: 12px; text-align: right; font-weight: bold; color: ${zeroPercentage >= 80 ? '#dc3545' : zeroPercentage >= 50 ? '#fd7e14' : '#28a745'};">${Math.round(zeroPercentage)}%</td>
                    </tr>
                `;
            });
            
            listHTML += `
                        </tbody>
                    </table>
                </div>
                <p style="margin-top: 15px; color: #666; font-size: 0.9em;">
                    å…±æ‰¾åˆ° ${buildings.length} å€‹åœ¨é¸å®šæ¢ä»¶ä¸‹æ›¾ç¶“åœæ»¿çš„åœè»Šå ´
                </p>
            `;
            
            tableContainer.innerHTML = listHTML;
            
            // æ·»åŠ æ’åºäº‹ä»¶ç›£è½å™¨
            document.querySelectorAll('.sortable-header').forEach(header => {
                header.addEventListener('click', function() {
                    const sortColumn = this.getAttribute('data-sort');
                    sortBuildings(sortColumn);
                });
            });
        }

        // ç²å–æ’åºæŒ‡ç¤ºå™¨çš„CSSé¡åˆ¥
        function getSortIndicatorClass(column) {
            if (currentSortColumn === column) {
                return currentSortOrder === 'asc' ? 'asc' : 'desc';
            }
            return 'unsorted';
        }

        // æ’åºå»ºç‰©åˆ—è¡¨
        function sortBuildings(column) {
            // å¦‚æœé»æ“Šçš„æ˜¯åŒä¸€åˆ—ï¼Œå‰‡åˆ‡æ›æ’åºæ–¹å‘
            if (currentSortColumn === column) {
                currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                // æ–°çš„åˆ—ï¼Œé è¨­ç‚ºé™åºï¼ˆå¾å¤§åˆ°å°ï¼‰
                currentSortColumn = column;
                currentSortOrder = 'desc';
            }
            
            // åŸ·è¡Œæ’åº
            currentBuildings.sort((a, b) => {
                let valueA, valueB;
                
                switch (column) {
                    case 'name':
                        valueA = a.name || '';
                        valueB = b.name || '';
                        break;
                    case 'city':
                        valueA = `${a.city} ${a.zone}`;
                        valueB = `${b.city} ${b.zone}`;
                        break;
                    case 'space_number':
                        valueA = parseInt(a.space_number || 0);
                        valueB = parseInt(b.space_number || 0);
                        break;
                    case 'avgRemaining':
                        valueA = a.avgRemaining || 0;
                        valueB = b.avgRemaining || 0;
                        break;
                    case 'avgParked':
                        valueA = a.avgParked || 0;
                        valueB = b.avgParked || 0;
                        break;
                    case 'zeroRemainingPercentage':
                        valueA = a.zeroRemainingPercentage || 0;
                        valueB = b.zeroRemainingPercentage || 0;
                        break;
                    default:
                        return 0;
                }
                
                // è™•ç†å­—ä¸²å’Œæ•¸å­—çš„æ¯”è¼ƒ
                if (typeof valueA === 'string' && typeof valueB === 'string') {
                    const comparison = valueA.localeCompare(valueB, 'zh-TW');
                    return currentSortOrder === 'asc' ? comparison : -comparison;
                } else {
                    if (currentSortOrder === 'asc') {
                        return valueA - valueB;
                    } else {
                        return valueB - valueA;
                    }
                }
            });
            
            // é‡æ–°é¡¯ç¤ºæ’åºå¾Œçš„åˆ—è¡¨
            displayFullBuildingsList(currentBuildings);
        }

        // Update summary for buildings display
        function updateSummaryForBuildings(buildings) {
            const totalBuildings = buildings.length;
            const totalSpaces = buildings.reduce((sum, b) => sum + parseInt(b.space_number || 0), 0);
            const operatingBuildings = buildings.filter(b => b.in_operation === '1').length;
            const cities = [...new Set(buildings.map(b => b.city))].length;

            document.getElementById('totalBuildings').textContent = totalBuildings;
            document.getElementById('totalSpaces').textContent = totalSpaces.toLocaleString();
            document.getElementById('avgAvailable').textContent = operatingBuildings + ' ç‡Ÿé‹ä¸­';
            document.getElementById('occupancyRate').textContent = cities + ' åŸå¸‚';
        }

        // Initialize modal functionality
        function initModal() {
            modal = document.getElementById('buildingModal');
            const closeBtn = document.getElementsByClassName('close')[0];
            
            // é»æ“Š X é—œé–‰æ¨¡æ…‹æ¡†
            closeBtn.onclick = function() {
                modal.style.display = 'none';
            };
            
            // é»æ“Šæ¨¡æ…‹æ¡†å¤–éƒ¨é—œé–‰
            window.onclick = function(event) {
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            };
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            init();
            initModal();
        });
    </script>
</body>
</html>